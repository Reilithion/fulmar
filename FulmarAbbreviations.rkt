#lang typed/racket

 ; Copyright (c) 2014 The University of Utah
 ;
 ; Permission is hereby granted, free of charge, to any person obtaining a copy
 ; of this software and associated documentation files (the "Software"), to
 ; deal in the Software without restriction, including without limitation the
 ; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ; sell copies of the Software, and to permit persons to whom the Software is
 ; furnished to do so, subject to the following conditions:
 ;
 ; The above copyright notice and this permission notice shall be included in
 ; all copies or substantial portions of the Software.
 ;
 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ; IN THE SOFTWARE.

(provide (all-defined-out))

(require "private/fulmar-core.rkt")
(require "standard-chunk.rkt")

(: space-after (NestofChunks * -> Chunk))
(define (space-after . chunks)
  (concat chunks space))
(: spaces-around (NestofChunks * -> Chunk))
(define (spaces-around . chunks)
  (concat space chunks space))
(: add-spaces (NestofChunks * -> Chunk))
(define (add-spaces . chunks)
  (apply between space chunks))
(: stmt (NestofChunks * -> Chunk))
(define (stmt . chunks)
  (concat (add-spaces chunks) ";"))
(: add-blank-lines (NestofChunks * -> Chunk))
(define (add-blank-lines . chunks)
  (apply between blank-line chunks))
(: typedef (Chunk Chunk -> Chunk))
(define (typedef first second)
  (typedef-smt first second))
(: stmt-typedef (Chunk Chunk -> Chunk))
(define (stmt-typedef first second)
  (stmt (typedef-smt first second)))
(: val-call (Chunk NestofChunks * -> Chunk))
(define (val-call fcn . args)
  (function-call fcn args))
(: stmt-call (Chunk NestofChunks * -> Chunk))
(define (stmt-call fcn . args)
  (stmt (function-call fcn args)))
(: val-member-call (Chunk Chunk NestofChunks * -> Chunk))
(define (val-member-call obj fcn . args)
  (member-function-call obj fcn args))
(: stmt-member-call (Chunk Chunk NestofChunks * -> Chunk))
(define (stmt-member-call obj fcn . args)
  (stmt (member-function-call obj fcn args)))
(define def-function function-define)
(define def-void-function void-function-define)
(define def-returning-function returning-function-define)
(define dcl-function function-declare)
(define dcl-no-inline-function general-function-declare)
(define dcl-static-function static-function-declare)
(define def-template template-define)
(define dcl-struct struct-declare)
(define def-struct struct-define)
(define dcl-template-struct template-struct-declare)
(: stmt-dcl-template-struct (Chunk NestofChunks NestofChunks * -> Chunk))
(define (stmt-dcl-template-struct name params . args)
  (stmt (apply dcl-template-struct name params args)))
(define def-template-struct template-struct-define)
(: stmt-def-template-struct (Chunk NestofChunks NestofChunks NestofChunks * -> Chunk))
(define (stmt-def-template-struct name params args . body)
  (stmt (apply def-template-struct name params args body)))
(: stmt-def-struct (Chunk NestofChunks * -> Chunk))
(define (stmt-def-struct name . body)
  (stmt (def-struct (dcl-struct name) body)))
(define type-template template-use)
(: typename (Chunk -> Chunk))
(define (typename pmtr)
  (add-spaces 'typename pmtr))
(: type-template-function (NestofChunks NestofChunks * -> Chunk))
(define (type-template-function name . pmtrs)
  (add-spaces 'template (apply type-template name pmtrs)))
(define section-public public-section)
(define section-private private-section)
(define val-construct constructor-assignment)
(define scope scope-resolution-operator)
(: enum (NestofChunks * -> Chunk))
(define (enum . enums)
  (stmt 'enum (body-list "," enums)))
(: pp-cond-or (Chunk Chunk (U Chunk False) -> Chunk))
(define (pp-cond-or name then else)
  (pp-conditional-ifdef name
                        (concat then)
                        (if (not else)
                            #false
                            (concat else))))
(: pp-threads-or (Chunk (U Chunk False) -> Chunk))
(define (pp-threads-or then else)
  (pp-cond-or 'FIELD_EXPRESSION_THREADS then else))
(: pp-threads-only (Chunk -> Chunk))
(define (pp-threads-only chunk)
  (pp-threads-or chunk #false))
(: pp-gpu-or (Chunk (U Chunk False) -> Chunk))
(define (pp-gpu-or then else)
  (pp-cond-or '__CUDACC__ then else))
(: pp-gpu-only (Chunk -> Chunk))
(define (pp-gpu-only chunk)
  (pp-gpu-or chunk #false))
(: pp-gpu-test-or (Chunk (U Chunk False) -> Chunk))
(define (pp-gpu-test-or then else)
  (pp-cond-or 'NEBO_GPU_TEST then else))
(: pp-gpu-test-only (Chunk -> Chunk))
(define (pp-gpu-test-only chunk)
  (pp-gpu-test-or chunk #false))
(: report-backend-or (Chunk (U Chunk False) -> Chunk))
(define (report-backend-or then else)
  (pp-cond-or 'NEBO_REPORT_BACKEND then else))
(: report-backend-only (Chunk -> Chunk))
(define (report-backend-only chunk)
  (report-backend-or chunk #false))
(: kernel-call (Chunk NestofChunks * -> Chunk))
(define (kernel-call name . args)
  (type-template name (template-list (template-list args))))
(: device-only (NestofChunks * -> Chunk))
(define (device-only . chunks)
  (add-spaces '__device__ chunks))
(: host-device (NestofChunks * -> Chunk))
(define (host-device . chunks)
  (add-spaces (pp-gpu-only (add-spaces '__host__ '__device__))
              chunks))
(: global-only (NestofChunks * -> Chunk))
(define (global-only . chunks)
  (add-spaces '__global__ chunks))
(: report-backend-cout (Chunk Chunk -> Chunk))
(define (report-backend-cout type backend-name)
  (report-backend-only (add-spaces (scope 'std 'cout)
                                   '<<
                                   (surround "\"" (add-spaces type 'Nebo backend-name))
                                   '<<
                                   (scope 'std 'endl))))
(: report-backend-start (Chunk -> Chunk))
(define (report-backend-start backend-name)
  (report-backend-cout 'Starting backend-name))
(: report-backend-finish (Chunk -> Chunk))
(define (report-backend-finish backend-name)
  (report-backend-cout 'Finished backend-name))
(: pp-debug-only (NestofChunks * -> Chunk))
(define (pp-debug-only . chunks)
  (pp-conditional-ifndef 'NDEBUG
                         (apply concat chunks)
                         #false))
(: paren (NestofChunks * -> Chunk))
(define (paren . chunks)
  (sur-paren (position-indent (apply add-spaces chunks))))
(: ter-cond (Chunk Chunk Chunk -> Chunk))
(define (ter-cond if then else)
  (paren if '? then ': else))
(: val-assign (Chunk NestofChunks * -> Chunk))
(define (val-assign lhs . rhs)
  (add-spaces lhs '= rhs))
(: stmt-assign (Chunk NestofChunks * -> Chunk))
(define (stmt-assign lhs . rhs)
  (stmt (apply val-assign lhs rhs)))
(: val-typed-assign (Chunk Chunk NestofChunks * -> Chunk))
(define (val-typed-assign type lhs . rhs)
  (apply val-assign (add-spaces type lhs) rhs))
(: stmt-typed-assign (Chunk Chunk NestofChunks * -> Chunk))
(define (stmt-typed-assign type lhs . rhs)
  (stmt (apply val-typed-assign type lhs rhs)))
(: val-typed-const-assign (Chunk Chunk NestofChunks * -> Chunk))
(define (val-typed-const-assign type lhs . rhs)
  (apply val-typed-assign (add-spaces 'const type) lhs rhs))
(: val-equal (Chunk NestofChunks * -> Chunk))
(define (val-equal lhs . rhs)
  (add-spaces lhs '== rhs))
(: val-not-equal (Chunk NestofChunks * -> Chunk))
(define (val-not-equal lhs . rhs)
  (add-spaces lhs '!= rhs))
(: val-less-than (Chunk NestofChunks * -> Chunk))
(define (val-less-than lhs . rhs)
  (add-spaces lhs '< rhs))
(: val-greater-than (Chunk NestofChunks * -> Chunk))
(define (val-greater-than lhs . rhs)
  (add-spaces lhs '> rhs))
(: val-lesser-equal (Chunk NestofChunks * -> Chunk))
(define (val-lesser-equal lhs . rhs)
  (add-spaces lhs '<= rhs))
(: val-greater-equal (Chunk NestofChunks * -> Chunk))
(define (val-greater-equal lhs . rhs)
  (add-spaces lhs '>= rhs))
(: val-add (Chunk NestofChunks * -> Chunk))
(define (val-add lhs . rhs)
  (add-spaces lhs '+ rhs))
(: val-subtract (Chunk NestofChunks * -> Chunk))
(define (val-subtract lhs . rhs)
  (add-spaces lhs '- rhs))
(: val-multiply (Chunk NestofChunks * -> Chunk))
(define (val-multiply lhs . rhs)
  (add-spaces lhs '* rhs))
(: val-divide (Chunk NestofChunks * -> Chunk))
(define (val-divide lhs . rhs)
  (add-spaces lhs '/ rhs))
(: val-modulo (Chunk NestofChunks * -> Chunk))
(define (val-modulo lhs . rhs)
  (add-spaces lhs '% rhs))
(: val-increment (Chunk -> Chunk))
(define (val-increment chunk)
  (concat chunk '++))
(: val-and (Chunk NestofChunks * -> Chunk))
(define (val-and lhs . rhs)
  (between (spaces-around '&&) lhs rhs))
(: val-or (Chunk NestofChunks * -> Chunk))
(define (val-or lhs . rhs)
  (between (spaces-around "||") lhs rhs))
(: val-not (Chunk -> Chunk))
(define (val-not chunk)
  (concat '! (paren chunk)))
(: val-negate (Chunk -> Chunk))
(define (val-negate chunk)
  (concat '- (paren chunk)))
(: const (NestofChunks * -> Chunk))
(define (const . chunks)
  (add-spaces chunks 'const))
(: ref (NestofChunks * -> Chunk))
(define (ref . chunks)
  (add-spaces chunks '&))
(: ptr (NestofChunks * -> Chunk))
(define (ptr . chunks)
  (add-spaces chunks '*))
(: function-pmtr (Chunk Chunk -> Chunk))
(define (function-pmtr type arg)
  (add-spaces type arg))
(: dcl-variable (Chunk Chunk -> Chunk))
(define (dcl-variable type arg)
  (add-spaces type arg))
(: stmt-dcl-variable (Chunk Chunk -> Chunk))
(define (stmt-dcl-variable type arg)
  (stmt (function-pmtr type arg)))
(: take-ptr (NestofChunks * -> Chunk))
(define (take-ptr . chunks)
  (concat '& chunks))
(: stmt-if (Chunk NestofChunks * -> Chunk))
(define (stmt-if check . then)
  (add-spaces (val-call 'if check)
              (body then)))
(: stmt-if-else (Chunk Chunk Chunk -> Chunk))
(define (stmt-if-else check then else)
  (between new-line
           (stmt-if check then)
           (add-spaces 'else (body else))))
(: stmt-for (Chunk Chunk Chunk NestofChunks * -> Chunk))
(define (stmt-for init check next . smts)
  (add-spaces (val-call 'for (add-spaces (stmt init)
                                         (stmt check)
                                         next))
              (body smts)))
