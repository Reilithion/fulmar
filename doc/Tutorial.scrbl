#lang scribble/manual

@title[#:tag "tutorial"]{Fulmar Tutorial}
@author[@author+email["Lucas Adam M. Paul" "reilithion+nebo@gmail.com" #:obfuscate? #f]]

@section[#:tag "hello-world"]{Hello, World!}

We'll begin by making a simple Hello World program using Fulmar. The full text
of the program will be followed by an explanation of how it generates the
corresponding C++.

@codeblock|{
#lang at-exp fulmar

(pp-include 'stdio.h)

(returning-function-define
 (general-function-declare 'main 'int)
 (list
  (function-call 'printf @string-literal{Hello, world!\n}))
 "0")
}|

The first line
(@racketfont{#lang @racketmodname[at-exp] @racketmodname[fulmar]}) tells Racket
that this is a Fulmar script. We are also using the @racketmodname[at-exp]
reader extension to make our lives easier when dealing with string literals.
More on that later.

Next, @racket[pp-include] (which stands for pre-processor include) causes Fulmar
to emit an include directive for stdio.h in the C++ output.
This corresponds to the output line:
@verbatim|{
#include <stdio.h>
}|

Next we have @racket[returning-function-define] which, unsurprisingly, defines a
returning function. It takes three arguments:
@itemlist[(list @item{A function declaration, provided by @racket[general-function-declare] in this case}
                @item{A function body, which must be a list of Fulmar statements}
                @item{A return value, which is a single Fulmar expression})]

To create the function declaration, @racket[general-function-declare] requires:
@itemlist[(list @item{The name of the function to define (main in this case)}
                @item{The return type of the function (an int)}
                @item{An argument specification (which may be empty)})]

We only need the one printf statement in the body of the main function, but it
must still be in a list. The @racket[function-call] form takes the name of the
function and all of its arguments. This is where the @racketmodname[at-exp]
reader extension helps us. We could have written:
@codeblock|{
(function-call 'printf (string-literal "Hello, world!\\n"))
}|

But notice the extra backslash. The @racketmodname[at-exp] syntax helps avoid a
whole lot of unnecessary escaping, and makes it look a lot more like C++.

Here is the complete C++ program generated by the above Fulmar script:
@verbatim|{
/* This file was generated by fulmar version 0.9.0. */

#include <stdio.h>
int main(void) { printf("Hello, world!\n"); return 0; }
}|
